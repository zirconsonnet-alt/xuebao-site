现在我们的生成器的硬过率，软评分，模型选择范式，并不是结果导向的，而真实作曲中，作曲家往往带着目的选择和弦，比如他想：我最后要进行到属和弦，那么我可以先离调使用2级大和弦，但是“目的”在我们的系统中还不是一等公民

你说的核心问题是：现在的范式是 “局部可行（硬约束）+ 局部偏好（软评分）+ 局部选择（policy）”，它天然是 myopic 的；而真实作曲很多决策是 对未来状态的条件化选择（“为了最后到 V，我现在先怎么铺垫”）。要让“目的”成为一等公民，关键不是再加几个 scorer，而是把系统从 筛选器 变成 带目标条件的规划器 / 控制器。

下面给你一套可以直接落到你现有架构（Stage/Pipeline/Generator/Lazy enumeration）上的设计路径，尽量不推翻已有东西。

1) 把“目的”定义成可计算的对象：Goal / Objective / Target

在你现在的系统里，“约束”是 boolean（Violation/None），“评分”是 float（越大越好），但它们都默认只看 当前候选 或 当前一步。

把“目的”做成一等公民，需要一个新接口层：它显式描述未来想满足的性质，并且能对“离目标还有多远”给出信号。

最小可用抽象：

Goal（目标）：一个对 未来轨迹 的谓词/代价函数

is_satisfied(ctx) -> bool（终局判定或阶段性判定）

distance(ctx) -> float 或 potential(ctx) -> float（势能/距离，越小越接近）

deadline / horizon（在第几步之前必须满足）

scope（作用于 Key/Mode/Chord 哪些层）

Objective（优化目标）：把多个 goal 与局部偏好合成一个可加权的目标函数

类似：J = Σ local_scores + λ * (Φ(next) - Φ(curr)) - penalty(violations)

这样“目的”就能被 pipeline 读到、累计、比较，并参与 beam 的排序，而不是只在 stage 内部临时起作用。

2) 在 Pipeline 层引入“前瞻评估”（lookahead），而不是让 Stage 只管一步

你现在的 Pipeline.run 里，每个 stage 对候选做 rank，然后立刻 apply 进入下一个 stage。这里缺少的是：候选的好坏取决于它能把你带到哪里。

两种成本从低到高的实现方式（都兼容你“懒枚举 + 预算 top_k”的约束）：

A. 目标势能（Potential-based shaping）：零前瞻，但可把目的注入每一步

在 GenerationContext 增加 goals 或 objective。

每次 stage.apply 后，Pipeline 额外加一项：

delta_goal = Φ(ctx_after) - Φ(ctx_before)（或相反，看你定义）

这样即便 Stage 没有看到未来，beam 的累计分也会偏向“朝目标靠近”的路径。

优点：改动小、速度快。
缺点：势能设计要靠谱，否则会“看起来在靠近，其实走偏”。

B. 有界前瞻（Bounded lookahead / rollout）：小规模“试走几步”

对每个候选，试着用一个轻量 policy（甚至就是 RandomPolicy）向前 rollout H 步，估计到达目标的概率/期望距离。

在 stage.expand 返回的 ScoredCandidate 上加一个 rollout_score（或把它加进 score）。

rollout 用 同样的懒枚举 + top_k 预算，但 H 很小（比如 2~4 个 stage）。

你可以只对 top-N（比如 stage 的前 8 个候选）做 rollout，控制成本。

优点：能表达“为了终点我愿意现在绕路”。
缺点：算力开销上升，但你已经有 stage_top_k 预算机制，完全可控。

3) 把“到属和弦”这种目的写成可操作的目标例子

以你举的例子：“最后要到属和弦（V）”。

它不是一句口号，而应该变成：

终局目标：最后一个 chord 的 function == Dominant 或 root == Degrees.V（看你域模型）

路径偏好：临近终点的 N 步内，和声功能流向要满足某种 cadence pattern（例如 ii–V / IV–V / V/V–V）

约束 vs 目标：

“最后必须是 V”是硬目标（deadline = last step）

“最好有 ii–V”是软目标（reward）

然后给它一个势能函数 Φ（示例思路）：

距离终点还很远：奖励“建立属功能倾向”的事件（出现 V/V、导音倾向、属七准备等）

越接近终点：更强烈惩罚“远离属功能”的选择，并强奖“临近 cadence”的片段

关键点：Φ 不能只看“当前和弦是不是 V”，而要看“当前状态是否让未来更容易到 V”。

4) 在你的代码结构里，“目的”应该放在哪儿
放在 GenerationContext

你现在 ctx 里有：

current_key_id, current_mode_id, progression, audit, rng

建议加：

goal_state（目标系统的内部状态，比如目标栈、deadline 指针）

objective 或 goals: list[Goal]

（可选）history_features（给评分器/目标用的缓存特征，避免重复算）

这让目标成为“全局态”，而不是某个 stage 的私货。

Pipeline 负责“全局排序依据”

现在 pipeline 用 acc + scored_cand.score 来累加。你要做的是把：

local_score（scorer 的和）

goal_progress（势能变化 / rollout 估计）

goal_violation_penalty（错过 deadline 的大惩罚）

统一成 pipeline 的累计分 acc'。

这样 Stage 仍然只需要产出候选（以及局部评分/约束），而“目的驱动”在 pipeline 一层完成，符合分层职责。

5) 让目标影响“候选空间”，而不只是影响排序

作曲里的“目的”不仅影响你怎么选，还影响你考虑哪些选项。你已经有 domain constraint（avoid_roots / must_include 等），这正是一个很好的接口点。

做法是：让 Goal 能生成 动态 domain，用于缩小/引导枚举空间：

goal.domain_hint(ctx, stage_type) -> KeyConstraint | ModeConstraint | ChordConstraint | None

例如“最后要 V”：

在最后 1~2 个和弦的 ChordStage，domain_hint 返回 must_include / avoid_roots，把空间强力收敛到 cadence 允许集合

在更早阶段，domain_hint 只轻微偏置（比如避免某些会让 cadence 更难达成的 root pattern）

这能显著减少你需要的 top_k 扫描预算，因为你从源头就减少了无关分支。

6) 目标是“一等公民”的验收标准

你可以用三个明确的验收标准判断是否真的做到“一等公民”：

目标可以被声明、组合、切换

例如：GoalStack([ReachDominantAtEnd(), AvoidParallelFifthsSoft(), BuildTensionCurve(...)])

目标参与 beam 的全局排序（不是只在某个 scorer 里加点分）

同一个局部高分候选，如果会导致未来无法满足目标，应在 beam 中被压下去

目标能影响枚举空间（domain_hint 或动态约束）

目标越紧，候选越收敛；目标越松，越探索

7) 你现在这套系统最小改动的落地顺序

按“收益/风险”给你一个推荐的实现顺序（不需要推翻现有 Stage/Generator）：

在 ctx 增加 goals/objective（先不改 stage）

在 Pipeline 的累计分里加入 goal 势能项（Potential-based shaping）

给 Goal 增加 deadline 机制（错过就大惩罚或直接判死）

给关键目标（如终点和弦）加 domain_hint（让末端强收敛）

对少量候选做 rollout（仅在必要 stage，且只对前 N 个候选）

做到第 4 步，你的系统就已经会表现得“像带目的的作曲”，第 5 步会让它更像“作曲家会为了终点暂时牺牲局部最优”。

如果你愿意把“目的”再提升一层（更接近真实作曲），下一步就是做 层级目标：先规划功能级轨迹（Tension/Function skeleton），再在 skeleton 上生成具体 mode/chord/voicing。这时 pipeline 本质上变成两层：macro planner + micro realizer。但按你现在的工程状态，先把上面这套 Goal/Objectives + shaping + domain_hint 做起来，性价比最高。

是不是把目的抽象为未来第N步对生成序列的约束规则？

可以这么做，而且这是把“目的”一等公民化的最小闭环：把目的表达成“对未来第 N 步（或区间）生成序列的约束/偏好”，然后让它参与 可行性判定 与 搜索排序。

但要注意两点：
1）如果你只把它做成“未来第 N 步的硬约束”，那它更像 deadline constraint，能保证到达，但不会指导你怎么走；
2）真实“目的”通常同时包含：终点约束 + 过程偏好 + 失败预警（可达性）。否则 beam 会在前面乱走，最后一步才发现走不回去。

下面给你一个更精确的抽象方式（仍然符合你说的“未来第 N 步约束”）：

1) 把目的拆成三类“面向未来的规则”
A. 终点硬目标（Deadline Constraint）

“第 N 步必须满足 P”
例如：最后一个和弦必须是 V（或 Dominant function）。

形式：require(step=N, predicate=...)

B. 区间/阶段目标（Window Constraint）

“在 [a,b] 之间至少/至多出现某类事件”
例如：倒数 2~1 步内必须出现属功能准备（ii 或 IV 或 V/V）。

形式：require_window(steps=[N-2, N-1], predicate=..., quantifier=exists/all/count>=k)

C. 软目标（Preference / Reward）

“最好在某些步满足 Q，否则扣分”
例如：为了到 V，允许离调的 II 大和弦作为准备（加分而非必须）。

形式：reward(step=t, feature=..., weight=...)

这三类合起来，才像作曲家的“目的”。

2) 为什么“只做未来第 N 步硬约束”不够

因为它没有提供可达性信号：

你现在选的候选是否把你带进了“从这里永远到不了第 N 步目标”的死区？

你要在第 N 步到 V，但当前和声功能走到某些区域后，你的硬规则（RootPattern/TurningPoint/Resolution 等）可能会让你回不来。

所以“目的”最好还提供一个：

D. 可达性/势能（Reachability / Potential）

它不是约束，而是一个快速估计：从当前状态到 deadline 目标的“距离/风险”。

形式：potential(ctx, remaining_steps) -> float（越小越可达 / 越大越危险）

这样 pipeline 的 beam 才会“朝能到达的区域走”。

3) 在你现有架构里的最贴合落点

你现在的 stage/pipeline 是按 KeyStage -> ModeStage -> ChordStage 交织，ctx.progression 记录 triplets。

“未来第 N 步约束”应该挂在 ChordStep index（也就是 progression 的长度），而不是 pipeline 的 stage index。否则 per_step_key=True 时会混乱。

建议你定义一个统一的“步计数”：

step = len(ctx.progression) 表示已经落地了多少个 chord

“第 N 步”指的是最终 len == N 时的那个 chord

那么目标规则检查点有两个：

硬检查：每次 apply 后，如果已超过 deadline 或在 deadline 上不满足，直接判 infeasible（相当于 hard constraint）

软 shaping：每次扩展候选时，用 potential/reward 去调整 beam 分数

4) 你的提法怎么落成一个干净接口

你说的“抽象为未来第 N 步对生成序列的约束规则”，我会把它写成：

FutureRule：带 scope（作用到哪一步/区间）、kind（hard/soft）、predicate（对 ctx 或 ctx+candidate 的判定）

关键是它要支持两种调用：

prune：提前剪枝（hard, 可判定 infeasible 的部分）

shape：给搜索提供方向（soft 或 potential）

否则它只是“终局验收”，不是真正驱动生成。

5) 一个简洁的结论

是的：目的可以被抽象成“未来第 N 步（或区间）上的规则”。

但要成为一等公民：你还需要让它提供“提前剪枝 + 搜索导向”，也就是硬 deadline + 软 shaping（势能/奖励），否则系统依旧是局部贪心 + 末端碰运气。

如果你接下来想把它直接嵌到你当前代码里，最小改动方案就是：在 Pipeline.run 的累计分里加入 goal_potential_delta，并在 Stage.expand(top_k=...) 采样候选时，用 goal.prune(prefix_ctx, candidate) 做一次快速过滤（比完整 constraint 更轻）。

如何能够为了目的提前剪纸，而不浪费CPU去评估那些本来就不可能达到目的的候选
已思考 19s

要做到“为了目的提前剪枝、避免把 CPU 浪费在注定到不了目标的候选上”，关键是把生成从“评分驱动”改成“可达性驱动 + 评分”两段式：

先用很便宜的 can_reach 判定把不可能达标的分支剪掉

只对“理论上能到”的候选再做硬约束细查、软评分、模型选择

下面给你一套在你当前 Stage/Pipeline/懒枚举/top_k 预算范式里最契合、且能显著省 CPU 的做法。

1) 先定义“目标”的最小可达性接口

对目标（例如“最后一步到属和弦 V”）提供一个必要条件判定：

输入：当前上下文 ctx（或应用候选后的 ctx'）+ 剩余步数 r

输出：True/False，含义是“在 放宽后的规则 下是否仍有可能在 r 步内达标”

注意必须是 放宽规则（superset） 的可达性：
如果连放宽规则都到不了，那真实规则更不可能到，所以剪枝是绝对安全的，不会误杀可行解。

2) 用“反向可达 DP”做强剪枝：一次预计算，多次复用

把“到目标”的可达性在一个抽象状态空间上做动态规划：

选一个足够小的抽象状态 S（不要用完整 ctx）

常用：(last_chord_function, last_root, turning_point_state, ... )

你可以按你的规则真正依赖哪些历史信息来选维度（比如 RootPatternRule 需要的最近若干 root pattern，就把那段 pattern 摘出来作为状态）

定义一个“放宽后的后继函数” succ_relaxed(S)

只保留肯定不会新增不可能性的限制（通常是不加任何限制，或只保留音乐上硬结构如“同一调性/同一模式的可构造和弦集合”）

目标是让 succ_relaxed 超集真实后继

反向 DP：

Good[0] = { S | S 满足 goal }

Good[r+1] = { S | succ_relaxed(S) 里存在一个 S' 属于 Good[r] }

这样在生成时，如果你还有 r 步到终局，你只要检查“应用候选后得到的抽象状态 S_next 是否 ∈ Good[r]”，不在就直接跳过，不评分、不排序、不进 beam。

这类剪枝对“终点目标 + deadline（最后一步必须满足）”极其有效。

3) 把剪枝放在你最省 CPU 的位置：枚举流上游

你现在 Stage.expand(top_k=...) 是：

从 propose(ctx) 流里拿候选

做硬约束检查

收集前 M 个通过者再评分

你要插入的剪枝顺序应当是：

can_reach（极便宜） → 硬约束（中等） → 软评分（最贵）

这样你就不会为“不可能达目标”的候选付出任何 scorer 成本，甚至硬约束成本也大幅减少。

如果你启用了 top_k 预算，这一步更关键：否则你可能采样到一堆“看起来局部合法但其实必死”的候选，导致 picked 填不满、beam 退化。

4) 进一步省：用“最短步数下界”做常数级剪枝

很多目标都有很强的“最少需要几步”的必要条件。

例子：终点要 V，且你的规则要求倒数第二步必须是准备功能（如 ii 或 IV 或 V/V），那么：

若剩余步数 r < 1 且当前不是 V：必死

若剩余步数 r < 2 且当前既不是 ii/IV/V/V 也不能一步到 V：必死

这种剪枝几乎是 O(1)，在你没有做完整 Good[r] DP 前也能先顶上。

它的形式是一个“下界估计” lb_steps_to_goal(S)：
如果 lb > r，直接剪。

这个下界也必须在放宽模型上计算（保证安全）。

5) 记忆化：把“死状态”缓存成转置表

即便你不用预计算 Good[r]，也可以在运行时缓存：

key = (abstract_state, remaining_steps, goal_id)

value = can_reach bool

因为 beam 会反复遇到相同的抽象状态（尤其你有 RootPattern / FunctionFlow 这类有限状态规则时），缓存能把剪枝判定从“重复推导”降为“哈希查表”。

6) 一个很贴合你工程的落地建议

你现在的最自然落点是：

在 GenerationContext 增加：

goals

target_length

在 Pipeline 里，每次扩展一个 Stage 前，计算“剩余 chord 步数 r”

在 Stage.expand 内部，当你从 propose 流拿到候选时：

先模拟一个 cheap apply（只更新抽象状态或用轻量函数 predict_next_state(ctx, cand)）

调 goal.can_reach(next_state, r-1)，False 就 continue

这样既不破坏你现有 propose 的懒枚举，也不需要扫描全空间。

7) 你最可能遇到的坑

抽象状态太小：剪枝不够强，但仍然安全（只会少剪，不会误杀）

抽象状态太大：预计算/缓存成本变高，反而拖慢

放宽模型不小心变成收紧模型：会误杀可行路径，这是最危险的
规则：宁可放得更宽，剪枝弱一点，也不要放得更紧

8) 一个可直接嵌入的最小代码骨架（无注释）
from dataclasses import dataclass
from typing import Callable, Dict, Generic, Hashable, Iterable, Optional, Set, Tuple, TypeVar

S = TypeVar("S", bound=Hashable)
C = TypeVar("C")

@dataclass(frozen=True, slots=True)
class Goal(Generic[S]):
    is_goal: Callable[[S], bool]
    succ_relaxed: Callable[[S], Iterable[S]]

class Reachability(Generic[S]):
    def __init__(self, goal: Goal[S], max_r: int):
        self.goal = goal
        self.max_r = max(0, int(max_r))
        self.good: Dict[int, Set[S]] = {}

    def build(self, all_states: Iterable[S]) -> None:
        states = set(all_states)
        g0 = {s for s in states if self.goal.is_goal(s)}
        self.good[0] = g0
        for r in range(1, self.max_r + 1):
            prev = self.good[r - 1]
            cur: Set[S] = set()
            for s in states:
                for t in self.goal.succ_relaxed(s):
                    if t in prev:
                        cur.add(s)
                        break
            self.good[r] = cur

    def can_reach(self, s: S, r: int) -> bool:
        r = max(0, min(self.max_r, int(r)))
        good = self.good.get(r)
        if good is None:
            return False
        return s in good


你可以把 S 设计成“和弦功能类 + 最近 root pattern + turning point 状态”这样的 tuple；all_states 可以按枚举得到（状态空间通常不大），或者只对运行中出现过的状态做增量构建。

如果你告诉我：

你的“目的”最常见是哪几类（到 V、到 I、某种 cadence、某种张力曲线、避免某类功能等）

现有规则里哪些是“只看最近 k 步”的（比如 RootPatternRule 看几步？TurningPointRule 看几步？）

我可以把“抽象状态 S 的最小字段集合”给你直接定出来，并给出 succ_relaxed 应该如何从你的 domain（Key/Mode/ChordId）里构造，确保剪枝强且绝对不误杀。

你说的动态规划是适合解决此类问题的吗

适合，但要看你把它用在哪一层、以及你愿意做多大程度的“状态抽象”。

你的问题本质是：在一个带约束的序列生成里，想在搜索早期就判定“这条分支以后无论怎么选都达不到目标”，从而剪枝。只要满足两个条件，动态规划（更准确说是可达性 DP / 逆向可达集）就是非常合适的工具：

目标是“有限步长内是否可达”的性质（deadline / 在某窗口内必须发生某事）

你能把生成过程压缩成一个有限状态自动机或近似的有限状态（只依赖最近 k 步或有限摘要）

在你的工程里（RootPatternRule、TurningPointRule、ResolutionRule 这类规则），它们天然就很像有限状态机：只看有限历史、只影响下一步可选集合。这正是 DP 擅长的结构。

DP 什么时候非常合适
1) 终点/窗口型目标

“最后一步必须是 V”

“倒数两步必须形成 cadence”

“第 t 步必须满足某性质”
这类都是典型的“有限时域可达性/满足性”问题，DP（或反向 BFS）可以给你一个集合 Good[r]：从哪些状态出发，剩余 r 步能到目标。查表剪枝几乎是 O(1)。

2) 规则依赖有限历史（k 阶 Markov）

你的很多规则看起来就是：

最近 1 步/几步的 root、function、turning point 状态

当前 key/mode 的身份
只要你把这些信息作为抽象状态 S，DP 就成立。

3) 你愿意用“放宽模型”做安全剪枝

你不必把所有硬规则都塞进 DP。只要 DP 的转移 succ_relaxed 是真实转移的超集，那么：

S ∉ Good[r] ⇒ 必死（安全剪枝）

S ∈ Good[r] ⇒ 只是“可能活”（不保证一定可行）

这就能大幅减少“注定死”的候选进入评分阶段。

DP 什么时候不那么合适
1) 状态太大、接近完整 ctx

如果你需要把大量细节（例如完整和弦集合、复杂声部进行细节）都放进状态，DP 的状态空间会爆炸，预计算不划算。

解决思路是：DP只用于和声骨架层（key/mode/chord function/root/pattern），不要拉上 arrangement/voicing 级别。

2) 目标是“整体最优”而非“是否可达”

DP最强的是“可达性/满足性”，其次是“最短/最小代价到达”。
如果你的“目的”是类似“全曲张力曲线尽量贴合某条连续曲线”这种高维软目标，DP仍可用，但更像成本规划（最短路、Viterbi），收益未必比 beam + shaping 更高。

对你这套架构的结论

用 DP 做“目的驱动剪枝”是合适的，尤其是你常说的“最后必须到某功能/某和弦”这种目标。

最合理的做法是：DP不直接决定作品好坏，只负责回答一个问题：
“从当前抽象状态出发，在剩余 r 步内有没有可能达成目标？”

这会直接减少 CPU：因为你能在 propose 流上游就丢弃必死候选，避免跑硬约束、避免跑 scorer、避免进 beam。

推荐落地策略（最稳的组合）

先做一个很便宜的下界剪枝（lb_steps_to_goal > r）

再做一个抽象状态的 Good[r] 可达集（反向 DP 或反向 BFS）

最后才做你现有的 hard_filter + soft_score

这样 DP 提供“强剪枝”，而你现有框架负责“在可行区域里选得更好”。

如果你愿意，我可以按你现有规则集（StartChordRule/ResolutionRule/FunctionFlowRule/TurningPointRule/RootPatternRule/RootCadencePositionRule）推一个“最小抽象状态 S 应该包含哪些字段”，以及每个字段对应哪条规则的依赖，这样 DP 会足够强且不会误杀。
